# -*- coding: utf-8 -*-
"""Finite Difference Option pricing

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aaJqwPiEtjxw6Qi1yFW8mIWiL6-9-lFb
"""

# -*- coding: utf-8 -*-
"""
Complete Finite Difference Option Pricing System
Includes all pricing methods, Greeks calculations, and main function
"""
import numpy as np

# ==================== PRICING METHODS ====================

def explicit_fin_diff(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Explicit finite difference method for pricing European options'''
    dt = T/N
    dx = sigma*np.sqrt(3*dt)
    nu = r - q - 0.5*sigma**2
    pu = 0.5*dt*((sigma/dx)**2 + nu/dx)
    pm = 1.0 - dt*(sigma/dx)**2 - r*dt
    pd = 0.5*dt*((sigma/dx)**2 - nu/dx)
    grid = np.zeros((N+1,2*Nj+1))

    # Asset prices at maturity
    St = [S*np.exp(-Nj*dx)]
    for j in range(1, 2*Nj+1):
        St.append(St[j-1]*np.exp(dx))

    # Option value at maturity
    for j in range(2*Nj+1):
        if CallPut == 'Call':
            grid[N,j] = max(0, St[j] - K)
        elif CallPut == 'Put':
            grid[N,j] = max(0, K - St[j])

    # Backwards computing through grid
    for i in range(N-1, -1, -1):
        for j in range(1, 2*Nj):
            grid[i,j] = pu*grid[i+1,j+1] + pm*grid[i+1,j] + pd*grid[i+1,j-1]
        grid[i,0] = grid[i,1]
        grid[i,2*Nj] = grid[i,2*Nj-1] + (St[2*Nj]-St[2*Nj-1])

    return grid[0,Nj]


def implicit_fin_diff(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Implicit finite difference method for pricing European options'''
    dt = T/N
    dx = sigma*np.sqrt(dt)
    nu = r - q - 0.5*sigma**2
    pu = -0.5*dt*((sigma/dx)**2 + nu/dx)
    pm = 1.0 + dt*(sigma/dx)**2 + r*dt
    pd = -0.5*dt*((sigma/dx)**2 - nu/dx)
    grid = np.zeros(2*Nj+1)

    # Asset prices at maturity
    St = [S*np.exp(-Nj*dx)]
    for j in range(1, 2*Nj+1):
        St.append(St[j-1]*np.exp(dx))

    # Option value at maturity
    for j in range(2*Nj+1):
        if CallPut == 'Call':
            grid[j] = max(0, St[j] - K)
        elif CallPut == 'Put':
            grid[j] = max(0, K - St[j])

    # Boundary Conditions
    if CallPut == 'Call':
        lambdaU = St[2*Nj] - St[2*Nj-1]
        lambdaL = 0.0
    elif CallPut == 'Put':
        lambdaU = 0.0
        lambdaL = -1.0*(St[1] - St[0])

    def tridiagonal(C,pU,pM,pD,lambda_L,lambda_U,nj):
        C1 = np.zeros(2*nj+1)
        pmp = [pM+pD]
        pp = [C[1]+pD*lambda_L]
        for j in range(2,2*nj):
            pmp.append(pM - pU*pD/pmp[j-2])
            pp.append(C[j] - pp[j-2]*pD/pmp[j-2])
        C1[2*nj] = (pp[len(pp)-1] + pmp[len(pmp)-1]*lambda_U)/(pU + pmp[len(pmp)-1])
        C1[2*nj-1] = C1[2*nj] - lambda_U
        for j in range(2*nj-2, -1, -1):
            C1[j] = (pp[j-1] - pU*C1[j+1])/pmp[j-1]
        C1[0] = C1[1] - lambda_L
        return C1

    for i in range(N):
        grid = tridiagonal(grid,pu,pm,pd,lambdaL,lambdaU,Nj)

    return grid[Nj]


def crank_nicolson(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Crank-Nicolson finite difference method for pricing European options'''
    dt = T/N
    dx = sigma*np.sqrt(dt)
    nu = r - q - 0.5*sigma**2
    pu = -0.25*dt*((sigma/dx)**2 + nu/dx)
    pm = 1.0 + 0.5*dt*((sigma/dx)**2) + 0.5*r*dt
    pd = -0.25*dt*((sigma/dx)**2 - nu/dx)
    grid = np.zeros(2*Nj+1)

    # Asset prices at maturity
    St = [S*np.exp(-Nj*dx)]
    for j in range(1, 2*Nj+1):
        St.append(St[j-1]*np.exp(dx))

    # Option value at maturity
    for j in range(2*Nj+1):
        if CallPut == 'Call':
            grid[j] = max(0, St[j] - K)
        elif CallPut == 'Put':
            grid[j] = max(0, K - St[j])

    # Boundary Conditions
    if CallPut == 'Call':
        lambdaU = St[2*Nj] - St[2*Nj-1]
        lambdaL = 0.0
    elif CallPut == 'Put':
        lambdaU = 0.0
        lambdaL = -1.0*(St[1] - St[0])

    def tridiagonal(C,pU,pM,pD,lambda_L,lambda_U,nj):
        C1 = np.zeros(2*nj+1)
        pmp = [pM+pD]
        pp = [-pU*C[2]-(pM-2)*C[1]-pD*C[0]+pD*lambda_L]

        for j in range(2,2*nj):
            pmp.append(pM - pU*pD/pmp[j-2])
            pp.append(-pU*C[j+1] - (pM-2)*C[j] - pD*C[j-1] - pp[j-2]*pD/pmp[j-2])

        C1[2*nj] = (pp[len(pp)-1] + pmp[len(pmp)-1]*lambda_U)/(pU + pmp[len(pmp)-1])
        C1[2*nj-1] = C1[2*nj] - lambda_U

        for j in range(2*nj-2, 0, -1):
            C1[j] = (pp[j-1] - pU*C1[j+1])/pmp[j-1]
        C1[0] = C1[1] - lambda_L
        return C1

    for i in range(N):
        grid = tridiagonal(grid,pu,pm,pd,lambdaL,lambdaU,Nj)

    return grid[Nj]


# ==================== GREEKS CALCULATIONS ====================

def exp_fin_diff_delta(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Calculate option Delta'''
    C1 = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, CallPut)
    A = S*0.01
    S1 = S+A
    C2 = explicit_fin_diff(S1, K, T, sigma, r, q, N, Nj, CallPut)
    delta = (C2-C1)/A
    return delta


def exp_fin_diff_gamma(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Calculate option Gamma'''
    C1 = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, CallPut)
    A = S*0.01
    S1 = S+A
    S2 = S-A
    C2 = explicit_fin_diff(S1, K, T, sigma, r, q, N, Nj, CallPut)
    C3 = explicit_fin_diff(S2, K, T, sigma, r, q, N, Nj, CallPut)
    gamma = (((C2-C1)/(S1-S)) - ((C1-C3)/(S-S2)))/(0.5*(S1-S2))
    return gamma


def exp_fin_diff_theta(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Calculate option Theta (time decay)'''
    C1 = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, CallPut)
    A = T*0.01
    T1 = T - A
    C2 = explicit_fin_diff(S, K, T1, sigma, r, q, N, Nj, CallPut)
    theta = (C2-C1)/A
    return theta


def exp_fin_diff_vega(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Calculate option Vega'''
    C1 = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, CallPut)
    A = sigma*0.01
    sigma1 = sigma+A
    C2 = explicit_fin_diff(S, K, T, sigma1, r, q, N, Nj, CallPut)
    vega = (C2-C1)/A
    return vega


def exp_fin_diff_rho(S,K,T,sigma,r,q,N,Nj,CallPut):
    '''Calculate option Rho'''
    C1 = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, CallPut)
    A = 0.01
    r1 = r + A
    C2 = explicit_fin_diff(S, K, T, sigma, r1, q, N, Nj, CallPut)
    rho = (C2-C1)/A
    return rho


# ==================== MAIN FUNCTION ====================

def main():
    '''
    Main function demonstrating option pricing and Greeks calculation
    '''
    print("=" * 70)
    print("FINITE DIFFERENCE METHODS - EUROPEAN OPTION PRICING")
    print("=" * 70)

    # Option parameters
    S = 100.0       # Current stock price
    K = 100.0       # Strike price
    T = 1.0         # Time to maturity (years)
    sigma = 0.25    # Volatility (25%)
    r = 0.05        # Risk-free rate (5%)
    q = 0.02        # Dividend yield (2%)
    N = 1000        # Number of time steps
    Nj = 100        # Number of price steps

    print("\nOption Parameters:")
    print(f"  Spot Price (S):         ${S:.2f}")
    print(f"  Strike Price (K):       ${K:.2f}")
    print(f"  Time to Maturity (T):   {T:.2f} years")
    print(f"  Volatility (σ):         {sigma*100:.2f}%")
    print(f"  Risk-Free Rate (r):     {r*100:.2f}%")
    print(f"  Dividend Yield (q):     {q*100:.2f}%")
    print(f"  Time Steps (N):         {N}")
    print(f"  Price Steps (Nj):       {Nj}")

    # Price European Call Option
    print("\n" + "=" * 70)
    print("EUROPEAN CALL OPTION")
    print("=" * 70)

    call_explicit = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, 'Call')
    call_implicit = implicit_fin_diff(S, K, T, sigma, r, q, N, Nj, 'Call')
    call_crank = crank_nicolson(S, K, T, sigma, r, q, N, Nj, 'Call')

    print(f"\nPricing Results:")
    print(f"  Explicit Method:        ${call_explicit:.4f}")
    print(f"  Implicit Method:        ${call_implicit:.4f}")
    print(f"  Crank-Nicolson Method:  ${call_crank:.4f}")

    # Calculate Greeks for Call
    print(f"\nGreeks (using Explicit Method):")
    delta_call = exp_fin_diff_delta(S, K, T, sigma, r, q, N, Nj, 'Call')
    gamma_call = exp_fin_diff_gamma(S, K, T, sigma, r, q, N, Nj, 'Call')
    theta_call = exp_fin_diff_theta(S, K, T, sigma, r, q, N, Nj, 'Call')
    vega_call = exp_fin_diff_vega(S, K, T, sigma, r, q, N, Nj, 'Call')
    rho_call = exp_fin_diff_rho(S, K, T, sigma, r, q, N, Nj, 'Call')

    print(f"  Delta:   {delta_call:.4f}  (price change per $1 move in underlying)")
    print(f"  Gamma:   {gamma_call:.4f}  (delta change per $1 move in underlying)")
    print(f"  Theta:   {theta_call:.4f}  (daily price decay)")
    print(f"  Vega:    {vega_call:.4f}  (price change per 1% volatility change)")
    print(f"  Rho:     {rho_call:.4f}  (price change per 1% rate change)")

    # Price European Put Option
    print("\n" + "=" * 70)
    print("EUROPEAN PUT OPTION")
    print("=" * 70)

    put_explicit = explicit_fin_diff(S, K, T, sigma, r, q, N, Nj, 'Put')
    put_implicit = implicit_fin_diff(S, K, T, sigma, r, q, N, Nj, 'Put')
    put_crank = crank_nicolson(S, K, T, sigma, r, q, N, Nj, 'Put')

    print(f"\nPricing Results:")
    print(f"  Explicit Method:        ${put_explicit:.4f}")
    print(f"  Implicit Method:        ${put_implicit:.4f}")
    print(f"  Crank-Nicolson Method:  ${put_crank:.4f}")

    # Calculate Greeks for Put
    print(f"\nGreeks (using Explicit Method):")
    delta_put = exp_fin_diff_delta(S, K, T, sigma, r, q, N, Nj, 'Put')
    gamma_put = exp_fin_diff_gamma(S, K, T, sigma, r, q, N, Nj, 'Put')
    theta_put = exp_fin_diff_theta(S, K, T, sigma, r, q, N, Nj, 'Put')
    vega_put = exp_fin_diff_vega(S, K, T, sigma, r, q, N, Nj, 'Put')
    rho_put = exp_fin_diff_rho(S, K, T, sigma, r, q, N, Nj, 'Put')

    print(f"  Delta:   {delta_put:.4f}  (price change per $1 move in underlying)")
    print(f"  Gamma:   {gamma_put:.4f}  (delta change per $1 move in underlying)")
    print(f"  Theta:   {theta_put:.4f}  (daily price decay)")
    print(f"  Vega:    {vega_put:.4f}  (price change per 1% volatility change)")
    print(f"  Rho:     {rho_put:.4f}  (price change per 1% rate change)")

    # Put-Call Parity Check
    print("\n" + "=" * 70)
    print("PUT-CALL PARITY VERIFICATION")
    print("=" * 70)
    print("\nPut-Call Parity: C - P = S*e^(-qT) - K*e^(-rT)")

    lhs = call_explicit - put_explicit
    rhs = S * np.exp(-q*T) - K * np.exp(-r*T)
    difference = abs(lhs - rhs)

    print(f"\n  Call Price - Put Price:           {lhs:.4f}")
    print(f"  S*e^(-qT) - K*e^(-rT):           {rhs:.4f}")
    print(f"  Absolute Difference:              {difference:.6f}")

    if difference < 0.01:
        print("  ✓ Put-Call Parity holds (within tolerance)")
    else:
        print("  ✗ Put-Call Parity violated (may need more grid points)")

    print("\n" + "=" * 70)
    print("ANALYSIS COMPLETE")
    print("=" * 70)


# ==================== EXECUTION ====================

if __name__ == "__main__":
    main()

